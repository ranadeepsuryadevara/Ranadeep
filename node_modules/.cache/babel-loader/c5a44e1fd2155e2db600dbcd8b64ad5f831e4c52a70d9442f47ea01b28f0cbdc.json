{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime-corejs3/helpers/toConsumableArray\";\nimport _objectSpread from \"@babel/runtime-corejs3/helpers/objectSpread2\";\nimport _sliceInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/slice\";\nimport _Object$keys from \"@babel/runtime-corejs3/core-js-stable/object/keys\";\nimport _concatInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/concat\";\nimport { isFreelyNamed, generateAbsoluteRefPatches } from '../helpers.js';\nexport default {\n  key: 'allOf',\n  plugin: function plugin(val, key, fullPath, specmap, patch) {\n    // Ignore replace patches created by $ref because the changes will\n    // occur in the original \"add\" patch and we don't want this plugin\n    // to redundantly processes those \"relace\" patches.\n    if (patch.meta && patch.meta.$$ref) {\n      return undefined;\n    }\n    var parent = _sliceInstanceProperty(fullPath).call(fullPath, 0, -1);\n    if (isFreelyNamed(parent)) {\n      return undefined;\n    }\n    if (!Array.isArray(val)) {\n      var err = new TypeError('allOf must be an array');\n      err.fullPath = fullPath; // This is an array\n\n      return err;\n    }\n    var alreadyAddError = false; // Find the original definition from the `patch.value` object\n    // Remove the `allOf` property so it doesn't get added to the result of the `allOf` plugin\n\n    var originalDefinitionObj = patch.value;\n    parent.forEach(function (part) {\n      if (!originalDefinitionObj) return; // bail out if we've lost sight of our target\n\n      originalDefinitionObj = originalDefinitionObj[part];\n    });\n    originalDefinitionObj = _objectSpread({}, originalDefinitionObj); // when we've lost sight, interrupt prematurely\n\n    if (_Object$keys(originalDefinitionObj).length === 0) {\n      return undefined;\n    }\n    delete originalDefinitionObj.allOf;\n    var patches = []; // remove existing content\n\n    patches.push(specmap.replace(parent, {}));\n    val.forEach(function (toMerge, i) {\n      if (!specmap.isObject(toMerge)) {\n        if (alreadyAddError) {\n          return null;\n        }\n        alreadyAddError = true;\n        var _err = new TypeError('Elements in allOf must be objects');\n        _err.fullPath = fullPath; // This is an array\n\n        return patches.push(_err);\n      } // Deeply merge the member's contents onto the parent location\n\n      patches.push(specmap.mergeDeep(parent, toMerge)); // Generate patches that migrate $ref values based on ContextTree information\n      // remove [\"allOf\"], which will not be present when these patches are applied\n\n      var collapsedFullPath = _sliceInstanceProperty(fullPath).call(fullPath, 0, -1);\n      var absoluteRefPatches = generateAbsoluteRefPatches(toMerge, collapsedFullPath, {\n        getBaseUrlForNodePath: function getBaseUrlForNodePath(nodePath) {\n          var _context;\n          return specmap.getContext(_concatInstanceProperty(_context = []).call(_context, _toConsumableArray(fullPath), [i], _toConsumableArray(nodePath))).baseDoc;\n        },\n        specmap: specmap\n      });\n      patches.push.apply(patches, _toConsumableArray(absoluteRefPatches));\n      return undefined;\n    }); // If there was an example in the original definition,\n    // keep it instead of merging with examples from other schema\n\n    if (originalDefinitionObj.example) {\n      var _context2;\n\n      // Delete other schema examples\n      patches.push(specmap.remove(_concatInstanceProperty(_context2 = []).call(_context2, parent, 'example')));\n    } // Merge back the values from the original definition\n\n    patches.push(specmap.mergeDeep(parent, originalDefinitionObj)); // If there was not an original $$ref value, make sure to remove\n    // any $$ref value that may exist from the result of `allOf` merges\n\n    if (!originalDefinitionObj.$$ref) {\n      var _context3;\n      patches.push(specmap.remove(_concatInstanceProperty(_context3 = []).call(_context3, parent, '$$ref')));\n    }\n    return patches;\n  }\n};","map":{"version":3,"names":["_toConsumableArray","_objectSpread","_sliceInstanceProperty","_Object$keys","_concatInstanceProperty","isFreelyNamed","generateAbsoluteRefPatches","key","plugin","val","fullPath","specmap","patch","meta","$$ref","undefined","parent","call","Array","isArray","err","TypeError","alreadyAddError","originalDefinitionObj","value","forEach","part","length","allOf","patches","push","replace","toMerge","i","isObject","_err","mergeDeep","collapsedFullPath","absoluteRefPatches","getBaseUrlForNodePath","nodePath","_context","getContext","baseDoc","apply","example","_context2","remove","_context3"],"sources":["C:/Users/JRS GROUPS/Desktop/React/ftask/node_modules/swagger-client/es/specmap/lib/all-of.js"],"sourcesContent":["import _toConsumableArray from \"@babel/runtime-corejs3/helpers/toConsumableArray\";\nimport _objectSpread from \"@babel/runtime-corejs3/helpers/objectSpread2\";\nimport _sliceInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/slice\";\nimport _Object$keys from \"@babel/runtime-corejs3/core-js-stable/object/keys\";\nimport _concatInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/concat\";\nimport { isFreelyNamed, generateAbsoluteRefPatches } from '../helpers.js';\nexport default {\n  key: 'allOf',\n  plugin: function plugin(val, key, fullPath, specmap, patch) {\n    // Ignore replace patches created by $ref because the changes will\n    // occur in the original \"add\" patch and we don't want this plugin\n    // to redundantly processes those \"relace\" patches.\n    if (patch.meta && patch.meta.$$ref) {\n      return undefined;\n    }\n\n    var parent = _sliceInstanceProperty(fullPath).call(fullPath, 0, -1);\n\n    if (isFreelyNamed(parent)) {\n      return undefined;\n    }\n\n    if (!Array.isArray(val)) {\n      var err = new TypeError('allOf must be an array');\n      err.fullPath = fullPath; // This is an array\n\n      return err;\n    }\n\n    var alreadyAddError = false; // Find the original definition from the `patch.value` object\n    // Remove the `allOf` property so it doesn't get added to the result of the `allOf` plugin\n\n    var originalDefinitionObj = patch.value;\n    parent.forEach(function (part) {\n      if (!originalDefinitionObj) return; // bail out if we've lost sight of our target\n\n      originalDefinitionObj = originalDefinitionObj[part];\n    });\n    originalDefinitionObj = _objectSpread({}, originalDefinitionObj); // when we've lost sight, interrupt prematurely\n\n    if (_Object$keys(originalDefinitionObj).length === 0) {\n      return undefined;\n    }\n\n    delete originalDefinitionObj.allOf;\n    var patches = []; // remove existing content\n\n    patches.push(specmap.replace(parent, {}));\n    val.forEach(function (toMerge, i) {\n      if (!specmap.isObject(toMerge)) {\n        if (alreadyAddError) {\n          return null;\n        }\n\n        alreadyAddError = true;\n\n        var _err = new TypeError('Elements in allOf must be objects');\n\n        _err.fullPath = fullPath; // This is an array\n\n        return patches.push(_err);\n      } // Deeply merge the member's contents onto the parent location\n\n\n      patches.push(specmap.mergeDeep(parent, toMerge)); // Generate patches that migrate $ref values based on ContextTree information\n      // remove [\"allOf\"], which will not be present when these patches are applied\n\n      var collapsedFullPath = _sliceInstanceProperty(fullPath).call(fullPath, 0, -1);\n\n      var absoluteRefPatches = generateAbsoluteRefPatches(toMerge, collapsedFullPath, {\n        getBaseUrlForNodePath: function getBaseUrlForNodePath(nodePath) {\n          var _context;\n\n          return specmap.getContext(_concatInstanceProperty(_context = []).call(_context, _toConsumableArray(fullPath), [i], _toConsumableArray(nodePath))).baseDoc;\n        },\n        specmap: specmap\n      });\n      patches.push.apply(patches, _toConsumableArray(absoluteRefPatches));\n      return undefined;\n    }); // If there was an example in the original definition,\n    // keep it instead of merging with examples from other schema\n\n    if (originalDefinitionObj.example) {\n      var _context2;\n\n      // Delete other schema examples\n      patches.push(specmap.remove(_concatInstanceProperty(_context2 = []).call(_context2, parent, 'example')));\n    } // Merge back the values from the original definition\n\n\n    patches.push(specmap.mergeDeep(parent, originalDefinitionObj)); // If there was not an original $$ref value, make sure to remove\n    // any $$ref value that may exist from the result of `allOf` merges\n\n    if (!originalDefinitionObj.$$ref) {\n      var _context3;\n\n      patches.push(specmap.remove(_concatInstanceProperty(_context3 = []).call(_context3, parent, '$$ref')));\n    }\n\n    return patches;\n  }\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}