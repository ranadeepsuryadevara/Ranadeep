{"ast":null,"code":"import _typeof from \"@babel/runtime-corejs3/helpers/typeof\";\nimport _Object$assign from \"@babel/runtime-corejs3/core-js-stable/object/assign\";\nimport _WeakMap from \"@babel/runtime-corejs3/core-js-stable/weak-map\";\nimport _sliceInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/slice\";\nimport _concatInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/concat\";\nimport _Promise from \"@babel/runtime-corejs3/core-js-stable/promise\";\nimport _Object$keys from \"@babel/runtime-corejs3/core-js-stable/object/keys\";\nimport _mapInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/map\";\nimport _URLSearchParams from \"@babel/runtime-corejs3/core-js-stable/url-search-params\";\nimport 'cross-fetch/polyfill';\n/* global fetch */\n\nimport jsYaml from 'js-yaml';\nimport url from 'url';\nimport lib from './index.js';\nimport createError from './create-error.js';\nimport { isFreelyNamed, absolutifyPointer } from '../helpers.js';\nimport { ACCEPT_HEADER_VALUE_FOR_DOCUMENTS } from '../../constants.js';\nvar ABSOLUTE_URL_REGEXP = /^([a-z]+:\\/\\/|\\/\\/)/i;\nvar JSONRefError = createError('JSONRefError', function cb(message, extra, oriError) {\n  this.originalError = oriError;\n  _Object$assign(this, extra || {});\n});\nvar docCache = {};\nvar specmapRefs = new _WeakMap();\nvar skipResolutionTestFns = [\n// OpenAPI 2.0 response examples\nfunction (path) {\n  return (\n    // [\"paths\", *, *, \"responses\", *, \"examples\"]\n    path[0] === 'paths' && path[3] === 'responses' && path[5] === 'examples'\n  );\n},\n// OpenAPI 3.0 Response Media Type Examples\nfunction (path) {\n  return (\n    // [\"paths\", *, *, \"responses\", *, \"content\", *, \"example\"]\n    path[0] === 'paths' && path[3] === 'responses' && path[5] === 'content' && path[7] === 'example'\n  );\n}, function (path) {\n  return (\n    // [\"paths\", *, *, \"responses\", *, \"content\", *, \"examples\", *, \"value\"]\n    path[0] === 'paths' && path[3] === 'responses' && path[5] === 'content' && path[7] === 'examples' && path[9] === 'value'\n  );\n},\n// OpenAPI 3.0 Request Body Media Type Examples\nfunction (path) {\n  return (\n    // [\"paths\", *, *, \"requestBody\", \"content\", *, \"example\"]\n    path[0] === 'paths' && path[3] === 'requestBody' && path[4] === 'content' && path[6] === 'example'\n  );\n}, function (path) {\n  return (\n    // [\"paths\", *, *, \"requestBody\", \"content\", *, \"examples\", *, \"value\"]\n    path[0] === 'paths' && path[3] === 'requestBody' && path[4] === 'content' && path[6] === 'examples' && path[8] === 'value'\n  );\n},\n// OAS 3.0 Parameter Examples\nfunction (path) {\n  return (\n    // [\"paths\", *, \"parameters\", *, \"example\"]\n    path[0] === 'paths' && path[2] === 'parameters' && path[4] === 'example'\n  );\n}, function (path) {\n  return (\n    // [\"paths\", *, *, \"parameters\", *, \"example\"]\n    path[0] === 'paths' && path[3] === 'parameters' && path[5] === 'example'\n  );\n}, function (path) {\n  return (\n    // [\"paths\", *, \"parameters\", *, \"examples\", *, \"value\"]\n    path[0] === 'paths' && path[2] === 'parameters' && path[4] === 'examples' && path[6] === 'value'\n  );\n}, function (path) {\n  return (\n    // [\"paths\", *, *, \"parameters\", *, \"examples\", *, \"value\"]\n    path[0] === 'paths' && path[3] === 'parameters' && path[5] === 'examples' && path[7] === 'value'\n  );\n}, function (path) {\n  return (\n    // [\"paths\", *, \"parameters\", *, \"content\", *, \"example\"]\n    path[0] === 'paths' && path[2] === 'parameters' && path[4] === 'content' && path[6] === 'example'\n  );\n}, function (path) {\n  return (\n    // [\"paths\", *, \"parameters\", *, \"content\", *, \"examples\", *, \"value\"]\n    path[0] === 'paths' && path[2] === 'parameters' && path[4] === 'content' && path[6] === 'examples' && path[8] === 'value'\n  );\n}, function (path) {\n  return (\n    // [\"paths\", *, *, \"parameters\", *, \"content\", *, \"example\"]\n    path[0] === 'paths' && path[3] === 'parameters' && path[4] === 'content' && path[7] === 'example'\n  );\n}, function (path) {\n  return (\n    // [\"paths\", *, *, \"parameters\", *, \"content\", *, \"examples\", *, \"value\"]\n    path[0] === 'paths' && path[3] === 'parameters' && path[5] === 'content' && path[7] === 'examples' && path[9] === 'value'\n  );\n}];\nvar shouldSkipResolution = function shouldSkipResolution(path) {\n  return skipResolutionTestFns.some(function (fn) {\n    return fn(path);\n  });\n}; // =========================\n// Core\n// =========================\n\n/**\n * This plugin resolves the JSON pointers.\n * A major part of this plugin deals with cyclic references via 2 mechanisms.\n * 1. If a pointer was already resolved before in this path, halt.\n * 2. If the patch value points to one of the ancestors in this path, halt.\n *\n * Note that either one of these mechanism is sufficient, both must be in place.\n * For examples:\n *\n * Given the following spec, #1 alone is insufficient because after the 2nd\n * application, there will be a cyclic object reference.\n *   a.b.c: $ref-d\n *   d.e.f: $ref-a (per #1, safe to return patch as no immediate cycle)\n *\n * Given the following spec, #2 alone is insufficient because although there will\n * never be any cyclic object reference, the plugin will keep producing patches.\n *   a: $ref-b\n *   b: $ref-a\n */\n\nvar plugin = {\n  key: '$ref',\n  plugin: function plugin(ref, key, fullPath, specmap) {\n    var specmapInstance = specmap.getInstance();\n    var parent = _sliceInstanceProperty(fullPath).call(fullPath, 0, -1);\n    if (isFreelyNamed(parent) || shouldSkipResolution(parent)) {\n      return undefined;\n    }\n    var _specmap$getContext = specmap.getContext(fullPath),\n      baseDoc = _specmap$getContext.baseDoc;\n    if (typeof ref !== 'string') {\n      return new JSONRefError('$ref: must be a string (JSON-Ref)', {\n        $ref: ref,\n        baseDoc: baseDoc,\n        fullPath: fullPath\n      });\n    }\n    var splitString = split(ref);\n    var refPath = splitString[0];\n    var pointer = splitString[1] || '';\n    var basePath;\n    try {\n      basePath = baseDoc || refPath ? absoluteify(refPath, baseDoc) : null;\n    } catch (e) {\n      return wrapError(e, {\n        pointer: pointer,\n        $ref: ref,\n        basePath: basePath,\n        fullPath: fullPath\n      });\n    }\n    var promOrVal;\n    var tokens;\n    if (pointerAlreadyInPath(pointer, basePath, parent, specmap)) {\n      // Cyclic reference!\n      // if `useCircularStructures` is not set, just leave the reference\n      // unresolved, but absolutify it so that we don't leave an invalid $ref\n      // path in the content\n      if (!specmapInstance.useCircularStructures) {\n        var _absolutifiedRef = absolutifyPointer(ref, basePath);\n        if (ref === _absolutifiedRef) {\n          // avoids endless looping\n          // without this, the ref plugin never stops seeing this $ref\n          return null;\n        }\n        return lib.replace(fullPath, _absolutifiedRef);\n      }\n    }\n    if (basePath == null) {\n      tokens = jsonPointerToArray(pointer);\n      promOrVal = specmap.get(tokens);\n      if (typeof promOrVal === 'undefined') {\n        promOrVal = new JSONRefError(\"Could not resolve reference: \".concat(ref), {\n          pointer: pointer,\n          $ref: ref,\n          baseDoc: baseDoc,\n          fullPath: fullPath\n        });\n      }\n    } else {\n      promOrVal = extractFromDoc(basePath, pointer); // eslint-disable-next-line no-underscore-dangle\n\n      if (promOrVal.__value != null) {\n        promOrVal = promOrVal.__value; // eslint-disable-line no-underscore-dangle\n      } else {\n        promOrVal = promOrVal.catch(function (e) {\n          throw wrapError(e, {\n            pointer: pointer,\n            $ref: ref,\n            baseDoc: baseDoc,\n            fullPath: fullPath\n          });\n        });\n      }\n    }\n    if (promOrVal instanceof Error) {\n      return [lib.remove(fullPath), promOrVal];\n    }\n    var absolutifiedRef = absolutifyPointer(ref, basePath);\n    var patch = lib.replace(parent, promOrVal, {\n      $$ref: absolutifiedRef\n    });\n    if (basePath && basePath !== baseDoc) {\n      return [patch, lib.context(parent, {\n        baseDoc: basePath\n      })];\n    }\n    try {\n      // prevents circular values from being constructed, unless we specifically\n      // want that to happen\n      if (!patchValueAlreadyInPath(specmap.state, patch) || specmapInstance.useCircularStructures) {\n        return patch;\n      }\n    } catch (e) {\n      // if we're catching here, path traversal failed, so we should\n      // ditch without sending any patches back up.\n      //\n      // this is a narrow fix for the larger problem of patches being queued\n      // and then having the state they were generated against be modified\n      // before they are applied.\n      //\n      // TODO: re-engineer specmap patch/state management to avoid this\n      return null;\n    }\n    return undefined;\n  }\n};\nvar mod = _Object$assign(plugin, {\n  docCache: docCache,\n  absoluteify: absoluteify,\n  clearCache: clearCache,\n  JSONRefError: JSONRefError,\n  wrapError: wrapError,\n  getDoc: getDoc,\n  split: split,\n  extractFromDoc: extractFromDoc,\n  fetchJSON: fetchJSON,\n  extract: extract,\n  jsonPointerToArray: jsonPointerToArray,\n  unescapeJsonPointerToken: unescapeJsonPointerToken\n});\nexport default mod; // =========================\n// Utilities\n// =========================\n\n/**\n * Resolves a path and its base to an abolute URL.\n * @api public\n */\n\nfunction absoluteify(path, basePath) {\n  if (!ABSOLUTE_URL_REGEXP.test(path)) {\n    if (!basePath) {\n      var _context;\n      throw new JSONRefError(_concatInstanceProperty(_context = \"Tried to resolve a relative URL, without having a basePath. path: '\".concat(path, \"' basePath: '\")).call(_context, basePath, \"'\"));\n    }\n    return url.resolve(basePath, path);\n  }\n  return path;\n}\n/**\n * Wraps an error as JSONRefError.\n * @param  {Error} e      the error.\n * @param  {Object} extra (optional) optional data.\n * @return {Error}        an instance of JSONRefError.\n * @api public\n */\n\nfunction wrapError(e, extra) {\n  var message;\n  if (e && e.response && e.response.body) {\n    var _context2;\n    message = _concatInstanceProperty(_context2 = \"\".concat(e.response.body.code, \" \")).call(_context2, e.response.body.message);\n  } else {\n    message = e.message;\n  }\n  return new JSONRefError(\"Could not resolve reference: \".concat(message), extra, e);\n}\n/**\n * Splits a pointer by the hash delimiter.\n * @api public\n */\n\nfunction split(ref) {\n  return (ref + '').split('#'); // eslint-disable-line prefer-template\n}\n/**\n * Extracts a pointer from its document.\n * @param  {String} docPath the absolute document URL.\n * @param  {String} pointer the pointer whose value is to be extracted.\n * @return {Promise}        a promise of the pointer value.\n * @api public\n */\n\nfunction extractFromDoc(docPath, pointer) {\n  var doc = docCache[docPath];\n  if (doc && !lib.isPromise(doc)) {\n    // If doc is already available, return __value together with the promise.\n    // __value is for special handling in cycle check:\n    // pointerAlreadyInPath() won't work if patch.value is a promise,\n    // thus when that promise is finally resolved, cycle might happen (because\n    // `spec` and `docCache[basePath]` refer to the exact same object).\n    // See test \"should resolve a cyclic spec when baseDoc is specified\".\n    try {\n      var v = extract(pointer, doc);\n      return _Object$assign(_Promise.resolve(v), {\n        __value: v\n      });\n    } catch (e) {\n      return _Promise.reject(e);\n    }\n  }\n  return getDoc(docPath).then(function (_doc) {\n    return extract(pointer, _doc);\n  });\n}\n/**\n * Clears all document caches.\n * @param  {String} item (optional) the name of the cache item to be cleared.\n * @api public\n */\n\nfunction clearCache(item) {\n  if (typeof item !== 'undefined') {\n    delete docCache[item];\n  } else {\n    _Object$keys(docCache).forEach(function (key) {\n      delete docCache[key];\n    });\n  }\n}\n/**\n * Fetches and caches a document.\n * @param  {String} docPath the absolute URL of the document.\n * @return {Promise}        a promise of the document content.\n * @api public\n */\n\nfunction getDoc(docPath) {\n  var val = docCache[docPath];\n  if (val) {\n    return lib.isPromise(val) ? val : _Promise.resolve(val);\n  } // NOTE: we need to use `mod.fetchJSON` in order to be able to overwrite it.\n  // Any tips on how to make this cleaner, please ping!\n\n  docCache[docPath] = mod.fetchJSON(docPath).then(function (doc) {\n    docCache[docPath] = doc;\n    return doc;\n  });\n  return docCache[docPath];\n}\n/**\n * Fetches a document.\n * @param  {String} docPath the absolute URL of the document.\n * @return {Promise}        a promise of the document content.\n * @api public\n */\n\nfunction fetchJSON(docPath) {\n  return fetch(docPath, {\n    headers: {\n      Accept: ACCEPT_HEADER_VALUE_FOR_DOCUMENTS\n    },\n    loadSpec: true\n  }).then(function (res) {\n    return res.text();\n  }).then(function (text) {\n    return jsYaml.load(text);\n  });\n}\n/**\n * Extracts a pointer from an object.\n * @param  {String[]} pointer the JSON pointer.\n * @param  {Object} obj       an object whose value is to be extracted.\n * @return {Object}           the value to be extracted.\n * @api public\n */\n\nfunction extract(pointer, obj) {\n  var tokens = jsonPointerToArray(pointer);\n  if (tokens.length < 1) {\n    return obj;\n  }\n  var val = lib.getIn(obj, tokens);\n  if (typeof val === 'undefined') {\n    throw new JSONRefError(\"Could not resolve pointer: \".concat(pointer, \" does not exist in document\"), {\n      pointer: pointer\n    });\n  }\n  return val;\n}\n/**\n * Converts a JSON pointer to array.\n * @api public\n */\n\nfunction jsonPointerToArray(pointer) {\n  var _context3;\n  if (typeof pointer !== 'string') {\n    throw new TypeError(\"Expected a string, got a \".concat(_typeof(pointer)));\n  }\n  if (pointer[0] === '/') {\n    pointer = pointer.substr(1);\n  }\n  if (pointer === '') {\n    return [];\n  }\n  return _mapInstanceProperty(_context3 = pointer.split('/')).call(_context3, unescapeJsonPointerToken);\n}\n/**\n * Unescapes a JSON pointer.\n * @api public\n */\n\nfunction unescapeJsonPointerToken(token) {\n  if (typeof token !== 'string') {\n    return token;\n  }\n  var params = new _URLSearchParams(\"=\".concat(token.replace(/~1/g, '/').replace(/~0/g, '~')));\n  return params.get('');\n}\n/**\n * Escapes a JSON pointer.\n * @api public\n */\n\nfunction escapeJsonPointerToken(token) {\n  var _context4;\n  var params = new _URLSearchParams([['', token.replace(/~/g, '~0').replace(/\\//g, '~1')]]);\n  return _sliceInstanceProperty(_context4 = params.toString()).call(_context4, 1);\n}\nfunction arrayToJsonPointer(arr) {\n  if (arr.length === 0) {\n    return '';\n  }\n  return \"/\".concat(_mapInstanceProperty(arr).call(arr, escapeJsonPointerToken).join('/'));\n}\nvar pointerBoundaryChar = function pointerBoundaryChar(c) {\n  return !c || c === '/' || c === '#';\n};\nfunction pointerIsAParent(pointer, parentPointer) {\n  if (pointerBoundaryChar(parentPointer)) {\n    // This is the root of the document, so its naturally a parent\n    return true;\n  }\n  var nextChar = pointer.charAt(parentPointer.length);\n  var lastParentChar = _sliceInstanceProperty(parentPointer).call(parentPointer, -1);\n  return pointer.indexOf(parentPointer) === 0 && (!nextChar || nextChar === '/' || nextChar === '#') && lastParentChar !== '#';\n} // =========================\n// Private\n// =========================\n\n/**\n * Checks if this pointer points back to one or more pointers along the path.\n */\n\nfunction pointerAlreadyInPath(pointer, basePath, parent, specmap) {\n  var _context5, _context7;\n  var refs = specmapRefs.get(specmap);\n  if (!refs) {\n    // Stores all resolved references of a specmap instance.\n    // Schema: path -> pointer (path's $ref value).\n    refs = {};\n    specmapRefs.set(specmap, refs);\n  }\n  var parentPointer = arrayToJsonPointer(parent);\n  var fullyQualifiedPointer = _concatInstanceProperty(_context5 = \"\".concat(basePath || '<specmap-base>', \"#\")).call(_context5, pointer); // dirty hack to strip `allof/[index]` from the path, in order to avoid cases\n  // where we get false negatives because:\n  // - we resolve a path, then\n  // - allOf plugin collapsed `allOf/[index]` out of the path, then\n  // - we try to work on a child $ref within that collapsed path.\n  //\n  // because of the path collapse, we lose track of it in our specmapRefs hash\n  // solution: always throw the allOf constructs out of paths we store\n  // TODO: solve this with a global register, or by writing more metadata in\n  // either allOf or refs plugin\n\n  var safeParentPointer = parentPointer.replace(/allOf\\/\\d+\\/?/g, ''); // Case 1: direct cycle, e.g. a.b.c.$ref: '/a.b'\n  // Detect by checking that the parent path doesn't start with pointer.\n  // This only applies if the pointer is internal, i.e. basePath === rootPath (could be null)\n\n  var rootDoc = specmap.contextTree.get([]).baseDoc;\n  if (basePath === rootDoc && pointerIsAParent(safeParentPointer, pointer)) {\n    // eslint-disable-line\n    return true;\n  } // Case 2: indirect cycle\n  //  ex1: a.$ref: '/b'  &  b.c.$ref: '/b/c'\n  //  ex2: a.$ref: '/b/c'  &  b.c.$ref: '/b'\n  // Detect by retrieving all the $refs along the path of parent\n  // and checking if any starts with pointer or vice versa.\n\n  var currPath = '';\n  var hasIndirectCycle = parent.some(function (token) {\n    var _context6;\n    currPath = _concatInstanceProperty(_context6 = \"\".concat(currPath, \"/\")).call(_context6, escapeJsonPointerToken(token));\n    return refs[currPath] && refs[currPath].some(function (ref) {\n      return pointerIsAParent(ref, fullyQualifiedPointer) || pointerIsAParent(fullyQualifiedPointer, ref);\n    });\n  });\n  if (hasIndirectCycle) {\n    return true;\n  } // No cycle, this ref will be resolved, so stores it now for future detection.\n  // No need to store if has cycle, as parent path is a dead-end and won't be checked again.\n\n  refs[safeParentPointer] = _concatInstanceProperty(_context7 = refs[safeParentPointer] || []).call(_context7, fullyQualifiedPointer);\n  return undefined;\n}\n/**\n * Checks if the value of this patch ends up pointing to an ancestor along the path.\n */\n\nfunction patchValueAlreadyInPath(root, patch) {\n  var ancestors = [root];\n  patch.path.reduce(function (parent, p) {\n    ancestors.push(parent[p]);\n    return parent[p];\n  }, root);\n  return pointToAncestor(patch.value);\n  function pointToAncestor(obj) {\n    return lib.isObject(obj) && (ancestors.indexOf(obj) >= 0 || _Object$keys(obj).some(function (k) {\n      return pointToAncestor(obj[k]);\n    }));\n  }\n}","map":{"version":3,"names":["_typeof","_Object$assign","_WeakMap","_sliceInstanceProperty","_concatInstanceProperty","_Promise","_Object$keys","_mapInstanceProperty","_URLSearchParams","jsYaml","url","lib","createError","isFreelyNamed","absolutifyPointer","ACCEPT_HEADER_VALUE_FOR_DOCUMENTS","ABSOLUTE_URL_REGEXP","JSONRefError","cb","message","extra","oriError","originalError","docCache","specmapRefs","skipResolutionTestFns","path","shouldSkipResolution","some","fn","plugin","key","ref","fullPath","specmap","specmapInstance","getInstance","parent","call","undefined","_specmap$getContext","getContext","baseDoc","$ref","splitString","split","refPath","pointer","basePath","absoluteify","e","wrapError","promOrVal","tokens","pointerAlreadyInPath","useCircularStructures","_absolutifiedRef","replace","jsonPointerToArray","get","concat","extractFromDoc","__value","catch","Error","remove","absolutifiedRef","patch","$$ref","context","patchValueAlreadyInPath","state","mod","clearCache","getDoc","fetchJSON","extract","unescapeJsonPointerToken","test","_context","resolve","response","body","_context2","code","docPath","doc","isPromise","v","reject","then","_doc","item","forEach","val","fetch","headers","Accept","loadSpec","res","text","load","obj","length","getIn","_context3","TypeError","substr","token","params","escapeJsonPointerToken","_context4","toString","arrayToJsonPointer","arr","join","pointerBoundaryChar","c","pointerIsAParent","parentPointer","nextChar","charAt","lastParentChar","indexOf","_context5","_context7","refs","set","fullyQualifiedPointer","safeParentPointer","rootDoc","contextTree","currPath","hasIndirectCycle","_context6","root","ancestors","reduce","p","push","pointToAncestor","value","isObject","k"],"sources":["C:/Users/JRS GROUPS/Desktop/React/ftask/node_modules/swagger-client/es/specmap/lib/refs.js"],"sourcesContent":["import _typeof from \"@babel/runtime-corejs3/helpers/typeof\";\nimport _Object$assign from \"@babel/runtime-corejs3/core-js-stable/object/assign\";\nimport _WeakMap from \"@babel/runtime-corejs3/core-js-stable/weak-map\";\nimport _sliceInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/slice\";\nimport _concatInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/concat\";\nimport _Promise from \"@babel/runtime-corejs3/core-js-stable/promise\";\nimport _Object$keys from \"@babel/runtime-corejs3/core-js-stable/object/keys\";\nimport _mapInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/map\";\nimport _URLSearchParams from \"@babel/runtime-corejs3/core-js-stable/url-search-params\";\nimport 'cross-fetch/polyfill';\n/* global fetch */\n\nimport jsYaml from 'js-yaml';\nimport url from 'url';\nimport lib from './index.js';\nimport createError from './create-error.js';\nimport { isFreelyNamed, absolutifyPointer } from '../helpers.js';\nimport { ACCEPT_HEADER_VALUE_FOR_DOCUMENTS } from '../../constants.js';\nvar ABSOLUTE_URL_REGEXP = /^([a-z]+:\\/\\/|\\/\\/)/i;\nvar JSONRefError = createError('JSONRefError', function cb(message, extra, oriError) {\n  this.originalError = oriError;\n\n  _Object$assign(this, extra || {});\n});\nvar docCache = {};\nvar specmapRefs = new _WeakMap();\nvar skipResolutionTestFns = [// OpenAPI 2.0 response examples\nfunction (path) {\n  return (// [\"paths\", *, *, \"responses\", *, \"examples\"]\n    path[0] === 'paths' && path[3] === 'responses' && path[5] === 'examples'\n  );\n}, // OpenAPI 3.0 Response Media Type Examples\nfunction (path) {\n  return (// [\"paths\", *, *, \"responses\", *, \"content\", *, \"example\"]\n    path[0] === 'paths' && path[3] === 'responses' && path[5] === 'content' && path[7] === 'example'\n  );\n}, function (path) {\n  return (// [\"paths\", *, *, \"responses\", *, \"content\", *, \"examples\", *, \"value\"]\n    path[0] === 'paths' && path[3] === 'responses' && path[5] === 'content' && path[7] === 'examples' && path[9] === 'value'\n  );\n}, // OpenAPI 3.0 Request Body Media Type Examples\nfunction (path) {\n  return (// [\"paths\", *, *, \"requestBody\", \"content\", *, \"example\"]\n    path[0] === 'paths' && path[3] === 'requestBody' && path[4] === 'content' && path[6] === 'example'\n  );\n}, function (path) {\n  return (// [\"paths\", *, *, \"requestBody\", \"content\", *, \"examples\", *, \"value\"]\n    path[0] === 'paths' && path[3] === 'requestBody' && path[4] === 'content' && path[6] === 'examples' && path[8] === 'value'\n  );\n}, // OAS 3.0 Parameter Examples\nfunction (path) {\n  return (// [\"paths\", *, \"parameters\", *, \"example\"]\n    path[0] === 'paths' && path[2] === 'parameters' && path[4] === 'example'\n  );\n}, function (path) {\n  return (// [\"paths\", *, *, \"parameters\", *, \"example\"]\n    path[0] === 'paths' && path[3] === 'parameters' && path[5] === 'example'\n  );\n}, function (path) {\n  return (// [\"paths\", *, \"parameters\", *, \"examples\", *, \"value\"]\n    path[0] === 'paths' && path[2] === 'parameters' && path[4] === 'examples' && path[6] === 'value'\n  );\n}, function (path) {\n  return (// [\"paths\", *, *, \"parameters\", *, \"examples\", *, \"value\"]\n    path[0] === 'paths' && path[3] === 'parameters' && path[5] === 'examples' && path[7] === 'value'\n  );\n}, function (path) {\n  return (// [\"paths\", *, \"parameters\", *, \"content\", *, \"example\"]\n    path[0] === 'paths' && path[2] === 'parameters' && path[4] === 'content' && path[6] === 'example'\n  );\n}, function (path) {\n  return (// [\"paths\", *, \"parameters\", *, \"content\", *, \"examples\", *, \"value\"]\n    path[0] === 'paths' && path[2] === 'parameters' && path[4] === 'content' && path[6] === 'examples' && path[8] === 'value'\n  );\n}, function (path) {\n  return (// [\"paths\", *, *, \"parameters\", *, \"content\", *, \"example\"]\n    path[0] === 'paths' && path[3] === 'parameters' && path[4] === 'content' && path[7] === 'example'\n  );\n}, function (path) {\n  return (// [\"paths\", *, *, \"parameters\", *, \"content\", *, \"examples\", *, \"value\"]\n    path[0] === 'paths' && path[3] === 'parameters' && path[5] === 'content' && path[7] === 'examples' && path[9] === 'value'\n  );\n}];\n\nvar shouldSkipResolution = function shouldSkipResolution(path) {\n  return skipResolutionTestFns.some(function (fn) {\n    return fn(path);\n  });\n}; // =========================\n// Core\n// =========================\n\n/**\n * This plugin resolves the JSON pointers.\n * A major part of this plugin deals with cyclic references via 2 mechanisms.\n * 1. If a pointer was already resolved before in this path, halt.\n * 2. If the patch value points to one of the ancestors in this path, halt.\n *\n * Note that either one of these mechanism is sufficient, both must be in place.\n * For examples:\n *\n * Given the following spec, #1 alone is insufficient because after the 2nd\n * application, there will be a cyclic object reference.\n *   a.b.c: $ref-d\n *   d.e.f: $ref-a (per #1, safe to return patch as no immediate cycle)\n *\n * Given the following spec, #2 alone is insufficient because although there will\n * never be any cyclic object reference, the plugin will keep producing patches.\n *   a: $ref-b\n *   b: $ref-a\n */\n\n\nvar plugin = {\n  key: '$ref',\n  plugin: function plugin(ref, key, fullPath, specmap) {\n    var specmapInstance = specmap.getInstance();\n\n    var parent = _sliceInstanceProperty(fullPath).call(fullPath, 0, -1);\n\n    if (isFreelyNamed(parent) || shouldSkipResolution(parent)) {\n      return undefined;\n    }\n\n    var _specmap$getContext = specmap.getContext(fullPath),\n        baseDoc = _specmap$getContext.baseDoc;\n\n    if (typeof ref !== 'string') {\n      return new JSONRefError('$ref: must be a string (JSON-Ref)', {\n        $ref: ref,\n        baseDoc: baseDoc,\n        fullPath: fullPath\n      });\n    }\n\n    var splitString = split(ref);\n    var refPath = splitString[0];\n    var pointer = splitString[1] || '';\n    var basePath;\n\n    try {\n      basePath = baseDoc || refPath ? absoluteify(refPath, baseDoc) : null;\n    } catch (e) {\n      return wrapError(e, {\n        pointer: pointer,\n        $ref: ref,\n        basePath: basePath,\n        fullPath: fullPath\n      });\n    }\n\n    var promOrVal;\n    var tokens;\n\n    if (pointerAlreadyInPath(pointer, basePath, parent, specmap)) {\n      // Cyclic reference!\n      // if `useCircularStructures` is not set, just leave the reference\n      // unresolved, but absolutify it so that we don't leave an invalid $ref\n      // path in the content\n      if (!specmapInstance.useCircularStructures) {\n        var _absolutifiedRef = absolutifyPointer(ref, basePath);\n\n        if (ref === _absolutifiedRef) {\n          // avoids endless looping\n          // without this, the ref plugin never stops seeing this $ref\n          return null;\n        }\n\n        return lib.replace(fullPath, _absolutifiedRef);\n      }\n    }\n\n    if (basePath == null) {\n      tokens = jsonPointerToArray(pointer);\n      promOrVal = specmap.get(tokens);\n\n      if (typeof promOrVal === 'undefined') {\n        promOrVal = new JSONRefError(\"Could not resolve reference: \".concat(ref), {\n          pointer: pointer,\n          $ref: ref,\n          baseDoc: baseDoc,\n          fullPath: fullPath\n        });\n      }\n    } else {\n      promOrVal = extractFromDoc(basePath, pointer); // eslint-disable-next-line no-underscore-dangle\n\n      if (promOrVal.__value != null) {\n        promOrVal = promOrVal.__value; // eslint-disable-line no-underscore-dangle\n      } else {\n        promOrVal = promOrVal.catch(function (e) {\n          throw wrapError(e, {\n            pointer: pointer,\n            $ref: ref,\n            baseDoc: baseDoc,\n            fullPath: fullPath\n          });\n        });\n      }\n    }\n\n    if (promOrVal instanceof Error) {\n      return [lib.remove(fullPath), promOrVal];\n    }\n\n    var absolutifiedRef = absolutifyPointer(ref, basePath);\n    var patch = lib.replace(parent, promOrVal, {\n      $$ref: absolutifiedRef\n    });\n\n    if (basePath && basePath !== baseDoc) {\n      return [patch, lib.context(parent, {\n        baseDoc: basePath\n      })];\n    }\n\n    try {\n      // prevents circular values from being constructed, unless we specifically\n      // want that to happen\n      if (!patchValueAlreadyInPath(specmap.state, patch) || specmapInstance.useCircularStructures) {\n        return patch;\n      }\n    } catch (e) {\n      // if we're catching here, path traversal failed, so we should\n      // ditch without sending any patches back up.\n      //\n      // this is a narrow fix for the larger problem of patches being queued\n      // and then having the state they were generated against be modified\n      // before they are applied.\n      //\n      // TODO: re-engineer specmap patch/state management to avoid this\n      return null;\n    }\n\n    return undefined;\n  }\n};\n\nvar mod = _Object$assign(plugin, {\n  docCache: docCache,\n  absoluteify: absoluteify,\n  clearCache: clearCache,\n  JSONRefError: JSONRefError,\n  wrapError: wrapError,\n  getDoc: getDoc,\n  split: split,\n  extractFromDoc: extractFromDoc,\n  fetchJSON: fetchJSON,\n  extract: extract,\n  jsonPointerToArray: jsonPointerToArray,\n  unescapeJsonPointerToken: unescapeJsonPointerToken\n});\n\nexport default mod; // =========================\n// Utilities\n// =========================\n\n/**\n * Resolves a path and its base to an abolute URL.\n * @api public\n */\n\nfunction absoluteify(path, basePath) {\n  if (!ABSOLUTE_URL_REGEXP.test(path)) {\n    if (!basePath) {\n      var _context;\n\n      throw new JSONRefError(_concatInstanceProperty(_context = \"Tried to resolve a relative URL, without having a basePath. path: '\".concat(path, \"' basePath: '\")).call(_context, basePath, \"'\"));\n    }\n\n    return url.resolve(basePath, path);\n  }\n\n  return path;\n}\n/**\n * Wraps an error as JSONRefError.\n * @param  {Error} e      the error.\n * @param  {Object} extra (optional) optional data.\n * @return {Error}        an instance of JSONRefError.\n * @api public\n */\n\n\nfunction wrapError(e, extra) {\n  var message;\n\n  if (e && e.response && e.response.body) {\n    var _context2;\n\n    message = _concatInstanceProperty(_context2 = \"\".concat(e.response.body.code, \" \")).call(_context2, e.response.body.message);\n  } else {\n    message = e.message;\n  }\n\n  return new JSONRefError(\"Could not resolve reference: \".concat(message), extra, e);\n}\n/**\n * Splits a pointer by the hash delimiter.\n * @api public\n */\n\n\nfunction split(ref) {\n  return (ref + '').split('#'); // eslint-disable-line prefer-template\n}\n/**\n * Extracts a pointer from its document.\n * @param  {String} docPath the absolute document URL.\n * @param  {String} pointer the pointer whose value is to be extracted.\n * @return {Promise}        a promise of the pointer value.\n * @api public\n */\n\n\nfunction extractFromDoc(docPath, pointer) {\n  var doc = docCache[docPath];\n\n  if (doc && !lib.isPromise(doc)) {\n    // If doc is already available, return __value together with the promise.\n    // __value is for special handling in cycle check:\n    // pointerAlreadyInPath() won't work if patch.value is a promise,\n    // thus when that promise is finally resolved, cycle might happen (because\n    // `spec` and `docCache[basePath]` refer to the exact same object).\n    // See test \"should resolve a cyclic spec when baseDoc is specified\".\n    try {\n      var v = extract(pointer, doc);\n      return _Object$assign(_Promise.resolve(v), {\n        __value: v\n      });\n    } catch (e) {\n      return _Promise.reject(e);\n    }\n  }\n\n  return getDoc(docPath).then(function (_doc) {\n    return extract(pointer, _doc);\n  });\n}\n/**\n * Clears all document caches.\n * @param  {String} item (optional) the name of the cache item to be cleared.\n * @api public\n */\n\n\nfunction clearCache(item) {\n  if (typeof item !== 'undefined') {\n    delete docCache[item];\n  } else {\n    _Object$keys(docCache).forEach(function (key) {\n      delete docCache[key];\n    });\n  }\n}\n/**\n * Fetches and caches a document.\n * @param  {String} docPath the absolute URL of the document.\n * @return {Promise}        a promise of the document content.\n * @api public\n */\n\n\nfunction getDoc(docPath) {\n  var val = docCache[docPath];\n\n  if (val) {\n    return lib.isPromise(val) ? val : _Promise.resolve(val);\n  } // NOTE: we need to use `mod.fetchJSON` in order to be able to overwrite it.\n  // Any tips on how to make this cleaner, please ping!\n\n\n  docCache[docPath] = mod.fetchJSON(docPath).then(function (doc) {\n    docCache[docPath] = doc;\n    return doc;\n  });\n  return docCache[docPath];\n}\n/**\n * Fetches a document.\n * @param  {String} docPath the absolute URL of the document.\n * @return {Promise}        a promise of the document content.\n * @api public\n */\n\n\nfunction fetchJSON(docPath) {\n  return fetch(docPath, {\n    headers: {\n      Accept: ACCEPT_HEADER_VALUE_FOR_DOCUMENTS\n    },\n    loadSpec: true\n  }).then(function (res) {\n    return res.text();\n  }).then(function (text) {\n    return jsYaml.load(text);\n  });\n}\n/**\n * Extracts a pointer from an object.\n * @param  {String[]} pointer the JSON pointer.\n * @param  {Object} obj       an object whose value is to be extracted.\n * @return {Object}           the value to be extracted.\n * @api public\n */\n\n\nfunction extract(pointer, obj) {\n  var tokens = jsonPointerToArray(pointer);\n\n  if (tokens.length < 1) {\n    return obj;\n  }\n\n  var val = lib.getIn(obj, tokens);\n\n  if (typeof val === 'undefined') {\n    throw new JSONRefError(\"Could not resolve pointer: \".concat(pointer, \" does not exist in document\"), {\n      pointer: pointer\n    });\n  }\n\n  return val;\n}\n/**\n * Converts a JSON pointer to array.\n * @api public\n */\n\n\nfunction jsonPointerToArray(pointer) {\n  var _context3;\n\n  if (typeof pointer !== 'string') {\n    throw new TypeError(\"Expected a string, got a \".concat(_typeof(pointer)));\n  }\n\n  if (pointer[0] === '/') {\n    pointer = pointer.substr(1);\n  }\n\n  if (pointer === '') {\n    return [];\n  }\n\n  return _mapInstanceProperty(_context3 = pointer.split('/')).call(_context3, unescapeJsonPointerToken);\n}\n/**\n * Unescapes a JSON pointer.\n * @api public\n */\n\n\nfunction unescapeJsonPointerToken(token) {\n  if (typeof token !== 'string') {\n    return token;\n  }\n\n  var params = new _URLSearchParams(\"=\".concat(token.replace(/~1/g, '/').replace(/~0/g, '~')));\n  return params.get('');\n}\n/**\n * Escapes a JSON pointer.\n * @api public\n */\n\n\nfunction escapeJsonPointerToken(token) {\n  var _context4;\n\n  var params = new _URLSearchParams([['', token.replace(/~/g, '~0').replace(/\\//g, '~1')]]);\n  return _sliceInstanceProperty(_context4 = params.toString()).call(_context4, 1);\n}\n\nfunction arrayToJsonPointer(arr) {\n  if (arr.length === 0) {\n    return '';\n  }\n\n  return \"/\".concat(_mapInstanceProperty(arr).call(arr, escapeJsonPointerToken).join('/'));\n}\n\nvar pointerBoundaryChar = function pointerBoundaryChar(c) {\n  return !c || c === '/' || c === '#';\n};\n\nfunction pointerIsAParent(pointer, parentPointer) {\n  if (pointerBoundaryChar(parentPointer)) {\n    // This is the root of the document, so its naturally a parent\n    return true;\n  }\n\n  var nextChar = pointer.charAt(parentPointer.length);\n\n  var lastParentChar = _sliceInstanceProperty(parentPointer).call(parentPointer, -1);\n\n  return pointer.indexOf(parentPointer) === 0 && (!nextChar || nextChar === '/' || nextChar === '#') && lastParentChar !== '#';\n} // =========================\n// Private\n// =========================\n\n/**\n * Checks if this pointer points back to one or more pointers along the path.\n */\n\n\nfunction pointerAlreadyInPath(pointer, basePath, parent, specmap) {\n  var _context5, _context7;\n\n  var refs = specmapRefs.get(specmap);\n\n  if (!refs) {\n    // Stores all resolved references of a specmap instance.\n    // Schema: path -> pointer (path's $ref value).\n    refs = {};\n    specmapRefs.set(specmap, refs);\n  }\n\n  var parentPointer = arrayToJsonPointer(parent);\n\n  var fullyQualifiedPointer = _concatInstanceProperty(_context5 = \"\".concat(basePath || '<specmap-base>', \"#\")).call(_context5, pointer); // dirty hack to strip `allof/[index]` from the path, in order to avoid cases\n  // where we get false negatives because:\n  // - we resolve a path, then\n  // - allOf plugin collapsed `allOf/[index]` out of the path, then\n  // - we try to work on a child $ref within that collapsed path.\n  //\n  // because of the path collapse, we lose track of it in our specmapRefs hash\n  // solution: always throw the allOf constructs out of paths we store\n  // TODO: solve this with a global register, or by writing more metadata in\n  // either allOf or refs plugin\n\n\n  var safeParentPointer = parentPointer.replace(/allOf\\/\\d+\\/?/g, ''); // Case 1: direct cycle, e.g. a.b.c.$ref: '/a.b'\n  // Detect by checking that the parent path doesn't start with pointer.\n  // This only applies if the pointer is internal, i.e. basePath === rootPath (could be null)\n\n  var rootDoc = specmap.contextTree.get([]).baseDoc;\n\n  if (basePath === rootDoc && pointerIsAParent(safeParentPointer, pointer)) {\n    // eslint-disable-line\n    return true;\n  } // Case 2: indirect cycle\n  //  ex1: a.$ref: '/b'  &  b.c.$ref: '/b/c'\n  //  ex2: a.$ref: '/b/c'  &  b.c.$ref: '/b'\n  // Detect by retrieving all the $refs along the path of parent\n  // and checking if any starts with pointer or vice versa.\n\n\n  var currPath = '';\n  var hasIndirectCycle = parent.some(function (token) {\n    var _context6;\n\n    currPath = _concatInstanceProperty(_context6 = \"\".concat(currPath, \"/\")).call(_context6, escapeJsonPointerToken(token));\n    return refs[currPath] && refs[currPath].some(function (ref) {\n      return pointerIsAParent(ref, fullyQualifiedPointer) || pointerIsAParent(fullyQualifiedPointer, ref);\n    });\n  });\n\n  if (hasIndirectCycle) {\n    return true;\n  } // No cycle, this ref will be resolved, so stores it now for future detection.\n  // No need to store if has cycle, as parent path is a dead-end and won't be checked again.\n\n\n  refs[safeParentPointer] = _concatInstanceProperty(_context7 = refs[safeParentPointer] || []).call(_context7, fullyQualifiedPointer);\n  return undefined;\n}\n/**\n * Checks if the value of this patch ends up pointing to an ancestor along the path.\n */\n\n\nfunction patchValueAlreadyInPath(root, patch) {\n  var ancestors = [root];\n  patch.path.reduce(function (parent, p) {\n    ancestors.push(parent[p]);\n    return parent[p];\n  }, root);\n  return pointToAncestor(patch.value);\n\n  function pointToAncestor(obj) {\n    return lib.isObject(obj) && (ancestors.indexOf(obj) >= 0 || _Object$keys(obj).some(function (k) {\n      return pointToAncestor(obj[k]);\n    }));\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}