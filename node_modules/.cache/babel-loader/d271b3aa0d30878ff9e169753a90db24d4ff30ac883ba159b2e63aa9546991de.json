{"ast":null,"code":"import _slicedToArray from \"@babel/runtime-corejs3/helpers/slicedToArray\";\nimport _toConsumableArray from \"@babel/runtime-corejs3/helpers/toConsumableArray\";\nimport _concatInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/concat\";\nimport _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\";\nimport traverse from 'traverse';\nimport URL from 'url'; // This will match if the direct parent's key exactly matches an item.\n\nvar freelyNamedKeyParents = ['properties']; // This will match if the grandparent's key exactly matches an item.\n// NOTE that this is for finding non-free paths!\n\nvar nonFreelyNamedKeyGrandparents = ['properties']; // This will match if the joined parent path exactly matches an item.\n//\n// This is mostly useful for filtering out root-level reusable item names,\n// for example `[\"definitions\", \"$ref\"]`\n\nvar freelyNamedPaths = [\n// Swagger 2.0\n'definitions', 'parameters', 'responses', 'securityDefinitions',\n// OpenAPI 3.0\n'components/schemas', 'components/responses', 'components/parameters', 'components/securitySchemes']; // This will match if any of these items are substrings of the joined\n// parent path.\n//\n// Warning! These are powerful. Beware of edge cases.\n\nvar freelyNamedAncestors = ['schema/example', 'items/example'];\nexport function isFreelyNamed(parentPath) {\n  var parentKey = parentPath[parentPath.length - 1];\n  var grandparentKey = parentPath[parentPath.length - 2];\n  var parentStr = parentPath.join('/');\n  return (\n    // eslint-disable-next-line max-len\n    freelyNamedKeyParents.indexOf(parentKey) > -1 && nonFreelyNamedKeyGrandparents.indexOf(grandparentKey) === -1 || freelyNamedPaths.indexOf(parentStr) > -1 || freelyNamedAncestors.some(function (el) {\n      return parentStr.indexOf(el) > -1;\n    })\n  );\n}\nexport function generateAbsoluteRefPatches(obj, basePath) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n    specmap = _ref.specmap,\n    _ref$getBaseUrlForNod = _ref.getBaseUrlForNodePath,\n    getBaseUrlForNodePath = _ref$getBaseUrlForNod === void 0 ? function (path) {\n      var _context;\n      return specmap.getContext(_concatInstanceProperty(_context = []).call(_context, _toConsumableArray(basePath), _toConsumableArray(path))).baseDoc;\n    } : _ref$getBaseUrlForNod,\n    _ref$targetKeys = _ref.targetKeys,\n    targetKeys = _ref$targetKeys === void 0 ? ['$ref', '$$ref'] : _ref$targetKeys;\n  var patches = [];\n  traverse(obj).forEach(function callback() {\n    if (_includesInstanceProperty(targetKeys).call(targetKeys, this.key) && typeof this.node === 'string') {\n      var nodePath = this.path; // this node's path, relative to `obj`\n\n      var fullPath = _concatInstanceProperty(basePath).call(basePath, this.path);\n      var absolutifiedRefValue = absolutifyPointer(this.node, getBaseUrlForNodePath(nodePath));\n      patches.push(specmap.replace(fullPath, absolutifiedRefValue));\n    }\n  });\n  return patches;\n}\nexport function absolutifyPointer(pointer, baseUrl) {\n  var _context2;\n  var _pointer$split = pointer.split('#'),\n    _pointer$split2 = _slicedToArray(_pointer$split, 2),\n    urlPart = _pointer$split2[0],\n    fragmentPart = _pointer$split2[1];\n  var newRefUrlPart = URL.resolve(urlPart || '', baseUrl || '');\n  return fragmentPart ? _concatInstanceProperty(_context2 = \"\".concat(newRefUrlPart, \"#\")).call(_context2, fragmentPart) : newRefUrlPart;\n}","map":{"version":3,"names":["_slicedToArray","_toConsumableArray","_concatInstanceProperty","_includesInstanceProperty","traverse","URL","freelyNamedKeyParents","nonFreelyNamedKeyGrandparents","freelyNamedPaths","freelyNamedAncestors","isFreelyNamed","parentPath","parentKey","length","grandparentKey","parentStr","join","indexOf","some","el","generateAbsoluteRefPatches","obj","basePath","_ref","arguments","undefined","specmap","_ref$getBaseUrlForNod","getBaseUrlForNodePath","path","_context","getContext","call","baseDoc","_ref$targetKeys","targetKeys","patches","forEach","callback","key","node","nodePath","fullPath","absolutifiedRefValue","absolutifyPointer","push","replace","pointer","baseUrl","_context2","_pointer$split","split","_pointer$split2","urlPart","fragmentPart","newRefUrlPart","resolve","concat"],"sources":["C:/Users/JRS GROUPS/Desktop/React/ftask/node_modules/swagger-client/es/specmap/helpers.js"],"sourcesContent":["import _slicedToArray from \"@babel/runtime-corejs3/helpers/slicedToArray\";\nimport _toConsumableArray from \"@babel/runtime-corejs3/helpers/toConsumableArray\";\nimport _concatInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/concat\";\nimport _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\";\nimport traverse from 'traverse';\nimport URL from 'url'; // This will match if the direct parent's key exactly matches an item.\n\nvar freelyNamedKeyParents = ['properties']; // This will match if the grandparent's key exactly matches an item.\n// NOTE that this is for finding non-free paths!\n\nvar nonFreelyNamedKeyGrandparents = ['properties']; // This will match if the joined parent path exactly matches an item.\n//\n// This is mostly useful for filtering out root-level reusable item names,\n// for example `[\"definitions\", \"$ref\"]`\n\nvar freelyNamedPaths = [// Swagger 2.0\n'definitions', 'parameters', 'responses', 'securityDefinitions', // OpenAPI 3.0\n'components/schemas', 'components/responses', 'components/parameters', 'components/securitySchemes']; // This will match if any of these items are substrings of the joined\n// parent path.\n//\n// Warning! These are powerful. Beware of edge cases.\n\nvar freelyNamedAncestors = ['schema/example', 'items/example'];\nexport function isFreelyNamed(parentPath) {\n  var parentKey = parentPath[parentPath.length - 1];\n  var grandparentKey = parentPath[parentPath.length - 2];\n  var parentStr = parentPath.join('/');\n  return (// eslint-disable-next-line max-len\n    freelyNamedKeyParents.indexOf(parentKey) > -1 && nonFreelyNamedKeyGrandparents.indexOf(grandparentKey) === -1 || freelyNamedPaths.indexOf(parentStr) > -1 || freelyNamedAncestors.some(function (el) {\n      return parentStr.indexOf(el) > -1;\n    })\n  );\n}\nexport function generateAbsoluteRefPatches(obj, basePath) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      specmap = _ref.specmap,\n      _ref$getBaseUrlForNod = _ref.getBaseUrlForNodePath,\n      getBaseUrlForNodePath = _ref$getBaseUrlForNod === void 0 ? function (path) {\n    var _context;\n\n    return specmap.getContext(_concatInstanceProperty(_context = []).call(_context, _toConsumableArray(basePath), _toConsumableArray(path))).baseDoc;\n  } : _ref$getBaseUrlForNod,\n      _ref$targetKeys = _ref.targetKeys,\n      targetKeys = _ref$targetKeys === void 0 ? ['$ref', '$$ref'] : _ref$targetKeys;\n\n  var patches = [];\n  traverse(obj).forEach(function callback() {\n    if (_includesInstanceProperty(targetKeys).call(targetKeys, this.key) && typeof this.node === 'string') {\n      var nodePath = this.path; // this node's path, relative to `obj`\n\n      var fullPath = _concatInstanceProperty(basePath).call(basePath, this.path);\n\n      var absolutifiedRefValue = absolutifyPointer(this.node, getBaseUrlForNodePath(nodePath));\n      patches.push(specmap.replace(fullPath, absolutifiedRefValue));\n    }\n  });\n  return patches;\n}\nexport function absolutifyPointer(pointer, baseUrl) {\n  var _context2;\n\n  var _pointer$split = pointer.split('#'),\n      _pointer$split2 = _slicedToArray(_pointer$split, 2),\n      urlPart = _pointer$split2[0],\n      fragmentPart = _pointer$split2[1];\n\n  var newRefUrlPart = URL.resolve(urlPart || '', baseUrl || '');\n  return fragmentPart ? _concatInstanceProperty(_context2 = \"\".concat(newRefUrlPart, \"#\")).call(_context2, fragmentPart) : newRefUrlPart;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}